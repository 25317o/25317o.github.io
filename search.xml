<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 笔记</title>
      <link href="/2023/03/11/gitNote/"/>
      <url>/2023/03/11/gitNote/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote><p>什么是版本控制</p></blockquote><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li><li>简单说就是用于管理多人协同开发项目的技术。</li></ul><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p><blockquote><p>常见版本控制工具</p></blockquote><p>主流的版本控制器如下 :</p><ul><li>Git</li><li>SVN</li><li>CVS</li><li>VSS</li><li>Visual Studio Online</li></ul><p>版本控制产品非常多，现在影响力最大且适用最广泛的是 Git 和 SVN </p><h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><p><strong>1、本地版本</strong></p><p>控制记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="https://s2.loli.net/2023/03/11/tyWKU9CSRTHpDxF.png" alt="RCS"></p><p><strong>2、集中版本控制（SVN）</strong> </p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p><img src="https://s2.loli.net/2023/03/11/tOEedxmTI2Xr4oF.png" alt="SVN"></p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制（Git）</strong></p><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://s2.loli.net/2023/03/11/FRWJom8X4MsPthp.png" alt="Git"></p><blockquote><p>Git 与 SVN 的区别</p></blockquote><ul><li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p></li><li><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p></li></ul><p>&#x3D;&#x3D;Git是目前世界上最先进的分布式版本控制系统&#x3D;&#x3D;</p><h2 id="Git环境安装"><a href="#Git环境安装" class="headerlink" title="Git环境安装"></a>Git环境安装</h2><blockquote><p>下载</p></blockquote><p>[git官网](<a href="https://git-scm.com/">Git (git-scm.com)</a>)下载</p><p>淘宝镜像下载 : <a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><blockquote><p>启动Git</p></blockquote><p><strong>Git Bash</strong> : Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD</strong> : Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p><p>1）cd : 改变目录。</p><p>2）cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）pwd : 显示当前所在的目录路径。</p><p>4）ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）rm: 删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）mkdir: 新建一个目录,就是新建一个文件夹。</p><p>8）rm -r : 删除一个文件夹, rm -r src 删除src目录</p><blockquote><p>rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</p></blockquote><p>9）mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）reset 重新初始化终端&#x2F;清屏。</p><p>11）clear 清屏。</p><p>12）history 查看命令历史。</p><p>13）help 帮助。</p><p>14）exit 退出。</p><p>15）#表示注释</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>所有的配置文件，其实都保存在本地！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看配置</span> </span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>查看不同级别的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta prompt_">　　</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前用户（global）配置</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p>Git相关的配置文件：</p><p>1）Git\etc\gitconfig ：Git 安装目录下的 gitconfig –system 系统级</p><p>2）C:\Users\Administrator\ .gitconfig 只适用于当前登录用户的配置 –global 全局</p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p><p><strong>设置用户名与邮箱（用户标识，必要）</strong><br>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><blockquote><p>git config –global user.name “名称”  #名称<br>git config –global user.email “邮箱”  #邮箱</p></blockquote><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><h2 id="Git基本理论（重要）"><a href="#Git基本理论（重要）" class="headerlink" title="Git基本理论（重要）"></a>Git基本理论（重要）</h2><p>三个区域<br>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://s2.loli.net/2023/03/11/2wLXv16kMIJQheR.png" alt="work"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://s2.loli.net/2023/03/11/SFNcPg7VuErMRyI.png" alt="work2"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。</li></ul><p><strong>工作流程</strong></p><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://s2.loli.net/2023/03/11/IJaQ6zWPnr2GgFT.png" alt="work3"></p><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><blockquote><p>创建工作目录与常用指令</p></blockquote><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://s2.loli.net/2023/03/11/l3FLJuH64qXAU8f.png" alt="work4"></p><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><blockquote><p>克隆远程仓库</p></blockquote><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> [url]  <span class="comment">#https://gitee.com/kuangstudy/openclass.git</span></span></span><br></pre></td></tr></table></figure><p>2、去 gitee 或者 github 上克隆一个测试！</p><p><strong>文件的四种状态</strong></p><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li><p><strong>Untracked</strong>: <strong>未跟踪</strong>, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add </code>状态变为<strong>Staged</strong>.</p></li><li><p><strong>Unmodify</strong>: <strong>文件已经入库</strong>, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<strong>Modified</strong>. 如果使用<code>git rm</code>移出版本库, 则成为<strong>Untracked</strong>文件</p></li><li><p><strong>Modified</strong>: <strong>文件已修改</strong>, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用<code>git checkout </code>则丢弃修改过, 返回到<strong>unmodify</strong>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改 !</p></li><li><p><strong>Staged</strong>: <strong>暂存状态</strong>，执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<strong>Unmodify</strong>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<strong>Modified</strong></p></li></ul><p><strong>查看文件状态</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有文件状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在程序主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为注释</span></span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><p><strong>提交文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .                  # 添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;消息内容&quot;    # 提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line">git push   # 将本地仓库推送到远程仓库</span><br><span class="line">git push origin 分支      # 将本地仓库推送到远程仓库指定分支</span><br></pre></td></tr></table></figure><h2 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h2><blockquote><p>github是有墙的，比较慢，在国内我们一般使用gitee，公司有时候会搭建自己的git服务器</p></blockquote><p>1、注册码云，完善个人信息</p><p>2、设置本机绑定SSH公钥，实现免密登陆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件会产生在 C:\Users\Administrator\.ssh 目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成公钥  -t rsa加密</span></span><br><span class="line">ssh-keygen -t rsa </span><br></pre></td></tr></table></figure><p>执行命令后文件夹中多了两个文件</p><p><img src="https://gitee.com/chen_qwer2580/picture/raw/master/img/image-20230302142933970.png" alt="image-20230302142933970"></p><p>将.pub中的公钥添加到gitee中即可</p><p>3、使用码云创建一个仓库</p><p><img src="https://s2.loli.net/2023/03/11/PeNkGqJRQ3TpLgm.png" alt="image-20230302143618006"></p><p>许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载…… 等限制</p><p>4、将仓库克隆到本地</p><p><strong>IDEA中集成Git</strong></p><p>将远程的空项目git文件复制到需要的项目中</p><p>修改文件，使用IDEA操作git。</p><ul><li><p>添加到暂存区</p></li><li><p>commit 提交</p></li><li><p>push到远程仓库</p></li></ul><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="https://s2.loli.net/2023/03/11/AnaurwXWORKH8m3.png" alt="image-20230303095519959"></p><p><img src="https://s2.loli.net/2023/03/11/KgG1rRHTOw4mXDq.png" alt="image-20230303095537799"></p><p><strong>git分支常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge [branch]</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程 笔记</title>
      <link href="/2023/03/10/threadNote/"/>
      <url>/2023/03/10/threadNote/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>说起进程，就不得不说夭<strong>程序</strong>。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</p><p>而<strong>进程</strong>则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位</p><p>通常在一个进程中可以包含若干个<strong>线程</strong>，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的的单位。</p><p>注意 : 很多多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错局。</p><ul><li>线程就是独立的执行路径;</li><li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程;main()称之为主线程，为系统的入口，用于执行整个程序;</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制;线程会带来额外的开销，如cpu调度时间，并发控制开销。</li><li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li></ul><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>三种创建方式 :</p><ul><li><p>Thread class —— 继承Thread类 (重点)</p></li><li><p>Runnable 接口 —— 实现Runnable接口 (重点)</p></li><li><p>Callable 接口 —— 实现Callable接口 (了解)</p></li></ul><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul><li>自定义线程类继承Thread类</li><li>重新run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//线程入口点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在听课======&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    <span class="type">StartThread1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartThread1</span>();</span><br><span class="line">    <span class="comment">//调用start()方法</span></span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程不一定执行，CPU安排调度</p></blockquote><h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><ul><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现runnable接口，重写run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程体</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在听课======&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//创建实现类对象</span></span><br><span class="line">    <span class="type">StartThread</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartThread</span>();</span><br><span class="line">    <span class="comment">//创建代理类对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st);</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li><p>继承Thread类</p><blockquote><p>子类继承Thread类具备多线程能力</p><p>启动线程 : 子类对象.start()</p><p>不建议使用 : 避免OOP单继承局限性</p></blockquote></li><li><p>实现Runnable接口</p><blockquote><p>实现接口Runnable具有多线程能力</p><p>启动线程 : 传入目标对象+Thread对象.start()</p><p>推荐使用 : 避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p></blockquote></li></ul><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><ul><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务 : ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</li><li>提交执行 :Future <Boolean> result1 &#x3D; ser.submit(t1);</li><li>获取结果 : boolean r1 &#x3D; result1.get()</li><li>关闭服务 : ser.shutdownNow();</li></ul><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>设置十张票,三个人抢购</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个线程同时操作一个对象买票例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> implement Runnable&#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tickerNums&lt;<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterrupdateException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;拿到了第&quot;</span>+ticketNums--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        <span class="comment">//Thread.currentThread().getName() 获取线程名</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">TestThread</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现抢的票有重复的:</p><p><img src="https://s2.loli.net/2023/03/11/BjAv2YaUTlysQbu.png" alt="image-20230130165512708"></p><h2 id="Lamda-表达式"><a href="#Lamda-表达式" class="headerlink" title="Lamda 表达式"></a>Lamda 表达式</h2><p>其实质属于函数式编程的概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(params) -&gt; expression[表达式]</span><br><span class="line">(params) -&gt; statement[语句]</span><br><span class="line">(params) -&gt; &#123;statements&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; System.out.println(<span class="string">&quot;i like lamda--&gt;&quot;</span>+a);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;多线程学习...&quot;</span>)).start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ilike = ()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;相当于直接重写了函数式接口中的方法，括号中可以放参数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化:可以去掉参数类型、有参数可以去掉括号、只有一句代码可以去掉&#123;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>为什么使用Lamda表达式</strong></p><blockquote><p>避免匿名内部类定义过多</p><p>可以让你的代码看起来很简洁</p><p>去掉了一堆没有意义的代码，只留下核心的逻辑</p></blockquote><p>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</p><p>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://s2.loli.net/2023/03/11/AYFi8IzQovR9tyk.png" alt="image-20230130195952824"></p><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a><strong>线程方法</strong></h2><ul><li>setPriority(int newPriority)更改线程的优先级在指定的毫秒数内</li><li>static void sleep(long millis)                 让当前正在执行的线程休眠</li><li>void join()                                                等待该线程终止</li><li>static void yield()                                   暂停当前正在执行的线程对象，并执行其他线程</li><li>void interrupt()                                     中断线程，别用这个方式</li><li>boolean isAlive()                                   测试线程是否处于活动状态</li></ul><p>线程进入死亡状态后就不能再次启动了。</p><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>不推荐使用JDK提供的stop().destroy()方法。【已废弃】推荐线程自己停止下来<br>建议使用一个标志位进行终止变量当flag&#x3D;false，则终止线程运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//1.线程中定义线程体使用的标识、</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//2.线程体使用该标识</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run...Thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.对外提供方法改变标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li>sleep(时间)指定当前线程阻塞的毫秒数;</li><li>sleep存在异常InterruptedException;</li><li>sleep时间达到后线程进入就绪状态;</li><li>sleep可以模拟网络延时，倒计时等。</li><li>每一个对象都有一个锁，sleep不会释放锁;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟倒计时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tenDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(num--);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep可以放大问题的发生性</p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><ul><li>礼让线程，让当前正在执行的线程暂停，但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li><strong>让CPU重新调度，礼让不一定成功！看CPU</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyYield</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程开始执行&quot;</span>);</span><br><span class="line">        Thread.<span class="keyword">yield</span>();<span class="comment">//礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程停止执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><ul><li><p>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p></li><li><p>可以想象为插队</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.join()</span><br></pre></td></tr></table></figure><h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p>Thread.State</p><ul><li><p>NEW</p><p>尚未启动的线程处于此状态</p></li><li><p>RUNNABLE</p><p>在Java虚拟机中执行的线程处于此状态</p></li><li><p>BLOCKED</p><p>被阻塞等待监视器锁定的线程处于此状态。</p></li><li><p>WAITING</p><p>正在等待另一个线程执行特定动作的线程处于此状态。</p></li><li><p>TIMED_WAITING</p><p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p></li><li><p>TERMINATED<br>已退出的线程处于此状态。</p></li></ul><p>一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">System.out.println(state);<span class="comment">//NEW</span></span><br><span class="line"></span><br><span class="line">threa.start();</span><br><span class="line">state = thread.getState();</span><br><span class="line">System.out.println(state);<span class="comment">//RUN</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul><li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p></li><li><p>线程的优先级用数字表示，范围从1~10.</p><ul><li>Thread.MIN_PRIORITY&#x3D; 1;</li><li>Thread.MAX_PRIORITY &#x3D; 10;</li><li>Thread.NORM_PRIORITY &#x3D; 5;</li></ul></li><li><p>使用以下方式改变或获取优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取线程优先级</span></span><br><span class="line">thread.getPriority();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程优先级</span></span><br><span class="line">thread.setPriority(<span class="number">10</span>);<span class="comment">//括号内为1-10，数字越大优先级越高，不一定先执行，看CPU</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护 —— daemon</p><ul><li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>如,后台记录操作日志,监控内存,垃圾回收等待..</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置为守护线程</span></span><br><span class="line">thread.setDaemon(<span class="literal">true</span>)<span class="comment">//默认false表示是用户线程，正常的线程都是用户线程...</span></span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>多个线程操作同一个资源</p><p><strong>并发</strong> : <strong>同一个对象</strong>被<strong>多个线程</strong>同时操作</p><ul><li>处理多线程问题时,多个线程访问同一个对象，并且某些线程还想修改这个对象.这时候我们就需要线程同步</li><li>线程同步其实就是一种等待机制,多个需要同时访问此对象的线程进入这个对象的<strong>等待池</strong>形成队列,等待前面线程使用完毕，下一个线程再使用</li></ul><p>形成条件 : <strong>队列+锁</strong></p><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时,也带来了访问冲突问题。为了保证数据在方法中被访问时的正确性,在访问时加入<strong>锁机制synchronized</strong>,当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题:</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li><li>在多线程竞争下，加锁，释放锁会导致比较多的 上下文切换 和 调度延时，引起性能问题;</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置，引起性能问题。</li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul><li>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是<strong>synchronized</strong>关键字，它包括两种用法∶synchronized方法 和 synchronized 块</li></ul><blockquote><p>同步方法: public synchronized void method(int args){}</p></blockquote><ul><li>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</li></ul><blockquote><p>缺陷:若将一个大的方法申明为synchronized 将会影响效率</p></blockquote><h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><ul><li>同步块 : synchronized(Obj){}</li><li>Obj 称之为 <strong>同步监视器</strong><ul><li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li></ul></li><li>同步监视器的执行过程<ol><li>第一个线程访问，锁定同步监视器，执行其中代码。</li><li>第二个线程访问，发现同步监视器被锁定，无法访问。</li><li>第一个线程访问完毕，解锁同步监视器。</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li></ol></li></ul><p>锁的对象就是变化的量</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有 “<strong>两个以上对象的锁</strong>” 时，就可能会发生“死锁”的问题。</p><p>死锁 ：多个线程互相占着对方需要的资源，然后形成僵持。</p><h3 id="死锁避免方法"><a href="#死锁避免方法" class="headerlink" title="死锁避免方法"></a>死锁避免方法</h3><p>产生死锁的四个必要条件:</p><ol><li>互斥条件:一个资源每次只能被一个进程使用。</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生</p><h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock (锁)"></a>Lock (锁)</h2><ul><li>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当</li><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</li><li>ReentrantLock 类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();<span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span>(ticketNums&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;<span class="comment">//保证线程安全的代码</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ticketNums--);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized 与 Lock 的对比</strong></p><ul><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放。</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM讲花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li><li>优先使用顺序：<ul><li>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外）</li></ul></li></ul><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p><strong>生产者消费者模式</strong></p><p>Java提供了几个方法解决线程之间的通信问题</p><ul><li>wait()表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</li><li>wait(long timeout)        指定等待的毫秒数</li><li>notify       唤醒一个处于等待状态的线程</li><li>notifyAll       唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</li></ul><p>注意 : 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException</p><p>解决方式一 :</p><p>并发协作模型“生产者&#x2F;消费者模式”—&gt;管程法</p><ul><li>生产者:负责生产数据的模块(可能是方法，对象，线程，进程);</li><li>消费者:负责处理数据的模块(可能是方法，对象，线程，进程);</li><li>缓冲区︰消费者不能直接使用生产者的数据，他们之间有个 “缓冲区”</li><li><strong>生产者将生产好的数据放入缓冲区,消费者从缓冲区拿出数据</strong></li></ul><p>解决方式二 :</p><p>并发协作模型“生产者&#x2F;消费者模式”—&gt;信号灯法</p><ul><li>使用标志位为true&#x2F;false解决</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li><p>背景 : 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p></li><li><p>思路 : 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p></li><li><p>好处 :</p><ul><li>提高响应速度（减少了创建新线程的时间)</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建)</li><li>便于线程管理(….)<ul><li>corePoolSize : 核心池的大小</li><li>maximumPoolSize : 最大线程数</li><li>keepAliveTime : 线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li><li><p>JDK 5.0起提供了线程池相关API : ExecutorService 和 Executors</p></li><li><p>ExecutorService : 真正的线程池接口。常见子类 ThreadPoolExecutor</p><ul><li>void execute(Runnable command) : 执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</li><li><T> Future<T> submit(Callable<T> task) : 执行任务，有返回值，一般用来执行Callable</li><li>void shutdown() : 关闭连接池</li></ul></li><li><p>Executors : 工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">//newFixedThreadPool 参数为：线程池大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
